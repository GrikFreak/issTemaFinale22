<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>

<style type="text/css">
body
{
    margin-left:  30px;
    margin-right: 30px;
};

P
{
    font-family: Tahoma;
    font-size: 10pt;
};

a, a:visited, a:active, a:link, a:hover {
    text-decoration: underline;
    color: #545454;
    background-color: transparent;
	font-size: 93%;
}

a:hover {
    background-color: #cccccc;
}


hr {
    clear: both;
    height: 1px;
    color: #242424;
    background-color: transparent;
}

h1, h2, h3 {
    color: #242424;
    clear: left;
    font: 100% Tahoma, Helvetica, Arial, sans-serif;
    margin-bottom: 0.5em;
    padding-top: 0.5em;
	border-radius: 10px;
	padding: 5px;
}

top {
	width: 100%;
}


#i {
    color: #ff1010;
}
tt{
	font-family: "Arial";
    font-size: 90%;
	color: #006600;
}
em{
	font-family: "Arial";
    font-size: 80%;
	font-weight: bold;
	border-style:solid;
	border-color: #abe876;
    color: #1632cc;
}
bc{
	font-family: "Arial";
	font-size: 90%;
	font-weight: bold;
    color: #990000;
	background-color: #fcf8c7;
}
ks{
	font-family: "Arial";
	font-weight: bold;
    color: #0000CD	;
	font-size: 90%;
}
kc{
	font-family: "Arial";
	font-weight: bold;
    color: #008000	;
	font-size: 90%;
}
kr{
	font-family: "Arial";
	font-weight: bold;
    color: #ff0000	;
	font-size: 90%;
}
pre{
	font-family: "Consolas";
	font-size: 85%;
	background-color: #f5f5f5;
	border: 1.5px solid silver;
	padding: 5px;
}
m{
	font-family: "Helvetica";
	line-height: 100%;
 	font-size: 75%;
}
div.body{

    font-size: 18px;
}
k{
    color: #990000;
	font-weight: bold;
	font-size: 90%;
}
h1 {
    font-size: 150%;
    background-color: #b2c0ff;
	padding: 10px;
}

h2 {
    background-color: #9ed8ff;
    font-size: 130%;
}

h3 {
	background-color: #e6ccff;
    font-size: 100%;
}
h4 {
    background-color: #ccffcc;
    font-size: 100%;
	width: 95%;
	border-radius: 5px;
	padding: 2px;
}
h5 {
    background-color: #d5ffb0;
    font-size: 100%;

}
div.req{
	background-color: #d9ffb3;
    font-size: 18px;
	width: 700px;
    border: 3px solid green;
    padding: 15px;
    margin: 10px;
}
div.remark{
	background-color: #E3F2FD;
    border: 1.5px solid #d5f2ed;
    padding: 15px;
    margin: 10px;
	border-radius: 25px;
}
table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}

#exampleclass tbody,
#exampleclass thead,
#exampleclass th {
  border: 0;
}

ol, ul, li {
  margin: 0;
  margin-left: 10px;
  padding: 0;
  padding-bottom: 5px;
}

table, th, td {
	border: 1px solid black;
}

img {
	border: 1.5px solid #d5f2ed

}

a, a:visited, a:active, a:link, a:hover {
    text-decoration: underline;
    color: #545454;
    background-color: transparent;
}

div.wrapdesc{
	width: 90%;
	margin: auto;
}

div.imagedesc{
	width: 85%;
	margin: auto;
}
</style>

<head>

<title>SPRINT 2 : Led and Sonar</title></head>

<body>
<div id="top">
<h1>SPRINT_2 : Led and Sonar<font size="5"></font> </h1>
</div>

<div class="body">

  <h2>Recap Sprint 1</h2>
  <div>
      <center><img src="images/CoreRobotArchitecture.png" alt="corerobot_logical_architecture" width="100%"></center>
      <br>
      <a href="https://github.com/GrikFreak/issTemaFinale22/blob/main/it.unibo.CoreAnalysis-Sprint1/src/CoreWSBasicRobot.qak"> <ks>Core with Robot Executable model</ks></a>
      <br><br>
      <div> <b>Relevant tests:</b>
        <br><br>
        <a href="https://github.com/GrikFreak/issTemaFinale22/blob/main/it.unibo.CoreAnalysis-Sprint1/test/TestWasteRequest.java" >TestWasteRequest</a>
        <br>
        <a href="https://github.com/GrikFreak/issTemaFinale22/blob/main/it.unibo.CoreAnalysis-Sprint1/test/TestPickUp.java" >TestPickUp</a>
      </div>
  </div>
<h2>Requirements</h2>
<div id="Requirements" class="remark">
  For the complete requirements see <a href="../../it.unibo.CoreAnalysis-Sprint1/userDocs/CoreAnalysis-Sprint1.2.html#requirments">Requirements</a>
</div>

<h2>Requirement analysis</h2>
<div class="remark">
<div class="remark" id = "Requirements_analysis">
  <h3>Led and Sonar requirements</h3>
  <h4><a href="#R3">R3</a></h4>
  <div class="remark" id="R1A">
    <kc>Formalization</kc>:the status of the LED changes according to the position and the status of the trolley; more precisly : 
        <li>The Led is off when the transport trolley is at HOME.</li>
        <li>The Led blinks while the transport trolley is moving.</li>
        <li>The Led is on when transport trolley is stopped.</li>
  </div>
  <h4><a href="#R4">R4</a></h4>
  <div class="remark" id="R1B">
    <kc>Formalization</kc>: The Sonar is used as an ‘alarm device’: when it measures a distance less that a prefixed value DLIMT, the transport trolley must be stopped. It will be resumed when Sonar detects again a distance higher than DLIMT.
  </div>
  <div>
    <a href="https://github.com/GrikFreak/issTemaFinale22/blob/main/it.unibo.Sprint2/src/sprint2.qak" > <ks>R3-R4 Executable model</ks></a>
  </div>

  <h3>Non-functional requirements</h3>
  <h4>Sonar</h4>
  <div class="remark" id="proactive">
    <kc>Proactive</kc>: The Sonar is a proactive actor because is in charge of compute the distance from an obstacle. 
  </div>
  <div class="remark" id="reactive">
    <kc>Reactive</kc>:The Sonar is also a reactive actor, because i the begging is started from the waste service.
  </div>
  <h4>Led</h4>
  <div class="remark" id="reactive">
    <kc>Reactive</kc>: The Led is only a reactive actor because it receives its status from the Waste Service
  </div>
  
</div>
<h2>Problem analysis</h2>
<div class="remark">
  <div>
   In this second sprint we will discuss the problematic concerned to the introduction of two new components, given by the commitment: 
   the <a href="https://github.com/anatali/issLab2022/tree/main/unibo.sonarqak22">SONAR</a> and the <a href="https://github.com/anatali/issLab2022/tree/main/unibo.ledqak22">LED</a>.
   Furthermore, the main problem that we have to handle is the way that these compenents will communicate each others. 
</div>
<h3>Led</h3>
<div class="remark" id=Led">
  The <kr>Led</kr> needs to update its status when the TransportTrolley changes its status.
  <h4>Problem n°0:How the transport Trolley comunicate its status to the WasteService</h4> 

  As it's the WasteService to command the TransportTrolley, to solve this problem
   we can keep track of the status and position of the trolley within the WasteService.

  <h4>Led Problem n°1: How to communicate the update of the Led status.</h4>  

  The WasteService needs to comunicate to the Led to change its status; we could do it by two type of comunincation.
 <li>through an <kr>event</kr>: it's the easiest way , but if a comunication prolem occurs the Led won't receive the message.
  Furthermore, if we use an event other components could receive the message.</li> 
 <li>through a <kr>dispatch</kr>: the strenght of the comunication is greater but in this way the Waste Service needs to know the existace of the Led. </li> 

  In our solution we use a dispatch.
 
 
</div>
<table cellpadding="20%" style="border: 0px solid transparent;width:98%;" style="width:98%">
  <tr>
    <td style="border: 0px">
        <center><img src="images/led.png" alt="Led" width="60%"><center>
    </td>
    <td style="border: 0px">
      <center><table cellpadding="5%">
        <tbody><tr>
            <th>Message</th>
            <th>Semantic</th>
        </tr>
        <tr>
            <td rowspan="1">led_status</td>
            <td rowspan="1">dispatch</td>
        </tr>
    </tbody></table></center>
  </td>
</tr>
</table>
<h3>Sonar </h3>
<div class="remark" id="Sonar">
  <h4>Problem n°1: Who is the best receiver of the distance emitted by the sonar?</h4>
The main role of sonar is to emit a continuous stream of data (measured distance) and send it to the Waste Service.
As it is a continous stream is not recommended to use dispatches or reply/request, but events;
with the help of events, the data emitted by the sonar can be received by several different entities:
<ul>
<ks>TransportTrolley:</ks>
	
		<li><kr>Pros</kr> : if the data were received directly from the trolley, it could automatically process the distances and stop itself.</li>
		<li><kr>Cons</kr>:the structure of the Trolley would be more complicated, giving up the role of pure actuator.</li>
	
	</ul>
	<ks>WasteService:</ks>
	<ul>
		<li><kr>Pros</kr>:If the data were received by the WasteService, it would become even more the fulcrum of the system.</li>
		<li><kr>Cons</kr>:the structure of the WasteService would be more complicated, and it would be  needed  to communicate the stop/resume action to the TransportTrolley.</li>
	</ul>

  <h4>Problem n°2: How the TransportTrolley receives the command Stop/Resume ? And from who ? </h4>
  If the Sonar data is received directly from the TransportTrolley then it will automatically stop based on the data received from the Sonar.
  If instead the data is received by the WasteService, it will be it who will send the command to the Trolley, which will keep the task of pure actuator in the system.
  The WasteService could send the command <ks>stop/resume</ks> in three different ways:

<li>through an <kr>event</kr>: it's the easiest way , but if a comunication prolem occur the TransportTrolley won't receive the message , causing dangerous consequences.</li> 
<li>through a <kr>dispatch</kr>: the strenght of the comunication is greater and so we don't have to think of possibile communication problems. </li> 
<li>through a <kr>request/reply</kr>: the strenght of the comunication is great, but the WasteService will have to wait a reply from the TransportTrolley.</li> 

<h4>Problem n°3: How to keep track of the TransportTrolley status when it's stopped? </h4>
When The TransportTrolley is stopped we need to keep in track which was its position and its status, and we need do resume it from the point it was left.
To solve this problem we need to discuss two cases:

<li> <kr>case 1:</kr>The TransportTrolley is <ks>moving</ks>.</li> 
<li> <kr>case 2:</kr>: the TransportTrolley is executing an action in a specific area.</li> 

<h5>CASE 1</h5>
if the TransportTrolley is moving ,  when the TransportTrolley is stopped, we need to remember the path remaining to complete the action and 
when it's resume we need to comunicate to the path executor the remaing path.
<h5>CASE 2</h5>
In this case we need to remember only the last state in which was the TransportTrolley , and resume it from the next one.
The problem that arise in this case is that we need to make sure that the Trolley has done everything in the last state otherwise we could encounter comunication problem if 
a reply, for example , is left behind.
<div>
  <h5>Where we save the status of the TransportTrolley?</h5>
The status of the Trolley could be saved in :

<li><kr>TransportTrolley:</kr> 
	<ul>
		<li><kr>Pros</kr>: With this solution we semplificate the computations of the WasteService </li>
		<li><kr>Cons</kr>:The WasteService needs to know anyway the Status of the Trolley.</li>
	</ul></li>
  <li><kr>WasteService:</kr> 
    <ul>
      <li><kr>Pros</kr>: It needs to know anyway the Status of the Trolley to compute other action , like changing the led status or comunicating it to the GUI.</li>
      <li><kr>Cons</kr>:the computational cost of the Waste Service is higher..</li>
    </ul></li>

</div>
<div>
  <h5>How to save the status of the TransportTrolley</h5>
  To save the status in which the Trolley is stopped we could use :
  
  <li><kr>A variable:</kr> 
    <ul>
      We could use a variable to save the status of the Trolley when is stopped and one to save the path remaining.
      This solution as an high computational cost because we need to update this 
      variable each time we change status. 
     </ul>
  </li>
    <li><kr>Interrupt:</kr>(<a href="https://htmlpreview.github.io/?https://github.com/anatali/issLab2022/blob/main/it.unibo.issLabStart/userDocs/Dispense/lezioni/html/RobotCleaner.html#stop-resume-un-nuovo-abstraction-gap">Interrupt_link</a>): 
      <ul>
        We could model a procedure call mechanism for the QAK language, in such  way we could memorize the state in which the TransportTrolley is ,  before the execution of the stop command.
        In this way we are  able to restore the Trolley correctly after the arrival of a resume.
      </ul>
    </li>
  </div>

  <div>
    <h5>How to comunicate to the path executor to stop</h5>
    To stop the Trolley when it's moving we need to send an alarm also to the path executor , which will stop the Trolley and send back a path_fail
    with the path remaining to the trolley.
    To send the alarm to the path_executor we could use :
    <li> an <kr>event</kr>: it's the easiest way , but if a comunication prolem occurs the Led won't receive the message.
      Furthermore, if we use an event other components could receive the message.</li> 
     <li> a <kr>dispatch</kr>: the strenght of the comunication is greater but in this way the Waste Service needs to know the existace of the Led. </li> 
    
     For now we decided to use an event, based on the precedence considerations and also because the path_executor natively support the event communication for stopping itself.
     If we decide to use a dispatch, we have to build the communication structure inside the path_executor.
     
    </div>
    <div>
     <h5>Which data we comuicate to the WasteService?</h5>
    The commitment gives us the Sonar component that includes a Distance clearear and a Distance Filter which eliminate
     the distances that we don't want to send to the WasteService (we want a precise range).
     So , then the sonar can filter the distances and sends directly a dispatch <ks>stop/resume</ks> to the WasteService. 
  
    </div>


    <table cellpadding="20%" style="border: 0px solid transparent;width:98%;" style="width:98%">
      <tr>
        <td style="border: 0px">
            <center><img src="images/sonarArchitecture.png" alt="Sonar" width="90%"><center>
        </td>
        <td style="border: 0px">
          <center><table cellpadding="5%">
            <tbody><tr>
                <th>Message</th>
                <th>Semantic</th>
            </tr>
            <tr>
                <td rowspan="1">stop</td>
                <td rowspan="1">dispatch</td>
            </tr>
            <tr>
              <td rowspan="1">resume</td>
              <td rowspan="1">dispatch</td>
          </tr>
        </tbody></table></center>
      </td>
    </tr>
    </table>

    <h5>Problems with distance filter stops</h5>
    To make easier the handling of stop/resume from waste service to TransportTrolley we decided to add a new <kr>request/reply</kr> called <b>transfer_request/transfer_done</b>. Due to differetiate the stop when the trolley is moving and when it is stopped at Indoor or in a Container.
    </br>
    </br>
    <ks>Request transfer_request : transfer_request(PATH_TO_DO)</ks>
    </br>
    <ks>Reply transfer_done : transfer_done(DONE)</ks>




  <!-- <div>
    <h5>FIRST DISTRIBUTION</h5>
    On the Raspberry there are two components of the system: the Led and the Sonar. 
    We could use only one application containing both the Led and the Sonar , in this case the distribution would 
    be easier buth the system will be less flessible and less extensible.
    Or we could use two applications, in this case we need to separate the Led and the sonar.

    As there are no specific requests from the client, the designer is left free to choose.

    </div> -->
    <!-- sonar -->
</div>

<h3>WasteTruck free indoor problem</h3>
<div class="remark" id="waste truck">
  <h4>Problem n°1: Why we need to use a dispatch to free the truck from indoor area?</h4>
  After a deeper analysis of the system, we concluded to add a new request/reply interaction between the waste truck 
  and the waste service for enable the waste truck to leave the indoor.
  <table cellpadding="20%" style="border: 0px solid transparent;width:98%;" style="width:98%">
    <tr>
      <br><br>
      <ks>Request free_request : free_request(ARG)</ks>
      <br>
      <ks>Reply free_indoor : free_indoor(DONE)</ks>
      <td style="border: 0px">
        <center><table cellpadding="5%">
          <tbody><tr>
              <th>Message</th>
              <th>Semantic</th>
          </tr>
          <tr>
              <td rowspan="1">free_request</td>
              <td rowspan="1">request</td>
          </tr>
          <tr>
            <td rowspan="1">free_indoor</td>
            <td rowspan="1">reply</td>
        </tr>
      </tbody></table></center>
    </td>
  </tr>
  </table>
</div>

<div id="logical_architecture">
  <h3>Logical Architecture</h3>
  From the previous considerations on the components of the system it is possible to define a first logical architecture: <br><br>
  <center><img src="images/architectureSprint2.1.png" alt="core_logical_architecture" width="100%"></center>
</div>




<h2>Test plans</h2>
<div id="test_plans">
  <div class="remark">
    Test plans are coded in Java (JUnit). 
    Since both tests develop more functionality of the System, both are integration tests.

    <h3>TestPlan: Sprint2</h3>
    <a href="https://github.com/GrikFreak/issTemaFinale22/blob/main/it.unibo.Sprint2/test/TestSprint2.java" >TestSprint2</a>
    
    <div><ks>TestLedOnAfterStop</ks>:</div>
    <div>in this test we verify the correct operation of the LED when the WasteService receives a stop. </li> 
    
    <div><ks>TestResumeAfterStop</ks>:</div>
    <div>in this test we verify the correct handling of the TransportTrolley when the sonar detects a distance less the distanceLimit, the WasteService sends the stop to the trolley and then the resume. </div> 
    
    <div><ks>TestBlinksAfterAcceptedLoad</ks>:</div>
    <div>in this test we verify the correct operation of the LED  when the WasteService accept a load. </div> 
    

    <h3>TestPlan: Led</h3> 
    <a href="https://github.com/GrikFreak/issTemaFinale22/blob/main/unibo.ledqak22/test/TestLed.java" >TestLed</a>
    
    <div><ks>Test testLedOn</ks>:</div>
    <div>It simulates that the WasteService sends a dispatch to turn the Led ON and verifiy the correct status of the Led. </div> 
  
    <div><ks>Test testLedOff</ks>:</div>
    <div>It simulates that the WasteService sends a dispatch to turn the Led OFF and verifiy the correct status of the Led. </div> 
    
    <div><ks>Test testLedBlinks</ks>:</div>
    <div>It simulates that the WasteService sends a dispatch to BLINKS the Led and verifiy the correct status of the Led. </div> 
  
  </div>
   
  
  

</div>

<h2>Project</h2> 
 <div class="remark">
  So far we have represented, for ease of notation, SONAR as a single actor. In reality
  it is implemented through a pipeline of actors. In particular, it is composed of the following two actors:
 <ul>
	<li>sonarHCSR04Support2021: use the <a href="../../supportiRaspberry/SonarAlone.c">SonarAlone</a>   provided by the customer
    to get the distances detected by the physical sonar and feed them into the pipeline.</li>
	<li>dataCleaner:filters the distances passed by the sonar HCSR04Support2021, considering only those included in a
    certain range. This is necessary since the physical sonar is made to detect distances not
    too high. </li>
 </ul><br>
  Altought we decided to introduce in the context of the WasteService a new actor, Distance Filter, a similar version to the one given by the commitment.
 	It has been modified for implementation needs, enriching it with business logic. It processes the distances coming from the dataCleaner and sends, when necessary, a dispatch to
  the  WasteService (distance higher or lower than DLIMIT). 
</br>
 As for the LED, however, we decided to create our own version inspired by the code provided by the
 client for implementation needs. In detail the LED is modeled as an actor and uses bash scripts
 provided by the customer to switch on (<a href="../../supportiRaspberry/led25GpioTurnOn.sh"> led25GpioTurnOn </a>) and switch off (<a href = "../../supportiRaspberry/led25GpioTurnOff.sh" > led25GpioTurnOff </a>)
 the physical LED. <br> <br>
 
 In addition to this, it was decided to restart the TransportTrolley in the resume phase in the state in which it was stopped,
 doing so facilitates the implementation of the actor, taking advantage of the transitions already present in the state
 without changing its structure excessively. <br> <br>
 
 Furthermore, at this stage, we have decided to split the Led and Sonar into two different applications in order to facilitate
 testing the system and increasing its flexibility and extensibility without overly complicating the distribution. <br> <br>
 
 </div>



</div>
<div><h1><b><a href="../../it.unibo.CoreAnalysis-Sprint1/userDocs/CoreAnalysis-Sprint1.2.html">Sprint1</a></b></h1></div>
<div><h1><b><a href="../../Sprint3-web/userDocs/Sprint3.html">Sprint3</a></b></h1></div>


<!-- <h2>Deployment</h2>
<div class="remark">
  Two applications are distributed on the Raspberry, one containing the <a href="../../distribuzione/unibo.led-1.0"> LED </a> and one the <a href = "../../ distribution /unibo.sonar-1.0">SONAR </a>, accompanied with the various
  codes related to physical LEDs and SONARs. <br>
  Finally, the remaining part of the system (TROLLEY and WASTE_SERVICE) resides on another node which in this case corresponds to the PC.</div>
</div> -->



<div style="background-color:rgba(86, 56, 253, 0.9); width:60%;text-align:left;color:white">
<li>By Bignami Filippo, Greco Davide, Rosadi Niccolò</li>
<li>email: filippo.bignami@studio.unibo.it,  davide.greco4@studio.unibo.it, niccolo.rosadi@studio.unibo.it</li>
<li>GitHub repository: https://github.com/GrikFreak/issTemaFinale22</li>
</div>
</body>
</html>